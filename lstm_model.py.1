import time
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F

class Encoder(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size, num_layers):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers, batch_first=True)

    def forward(self, x):
        x = self.embedding(x)
        outputs, hidden = self.lstm(x)
        return outputs, hidden  # Hidden state is passed to decoder

class Decoder(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size, num_layers):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, vocab_size)

    def forward(self, x, hidden):
        x = self.embedding(x)
        output, hidden = self.lstm(x, hidden)
        output = self.fc(output)
        return output, hidden

class Seq2Seq(nn.Module):
    def __init__(self, encoder, decoder):
        super().__init__()
        self.encoder = encoder
        self.decoder = decoder

    def forward(self, question, answer_input):
        _, hidden = self.encoder(question)  # Encode question
        output, _ = self.decoder(answer_input, hidden)  # Decode to get answer
        return output

def complete(args, device, corpus, text: str):
    input = corpus.tokenize(text);
    #input = torch.tensor(input).type(torch.int64)
    #input = input.reshape(-1, 1).to(device)
    input = torch.tensor([input]).to(device)

    hidden = torch.zeros(args.nlayers, 1, args.nhid).to(device)

    # Turn on evaluation mode which disables dropout.
    model.eval()
    ntokens = len(corpus.dictionary.idx2word)
    temperature = 0.7

    with torch.no_grad():
       for i in range(10):
                # data, targets = get_batch(source, 0)
#        if args.model == 'Transformer':
            output, hidden = model(input, hidden)

            predicted_word_idx = torch.argmax(output[0, -1, :]).item()
            # probs = F.softmax(output[:, -1, :] / temperature, dim=-1)
            # predicted_word_idx = torch.multinomial(probs, 1) 

            input = torch.tensor([[predicted_word_idx]]).to(device)
            w = corpus.dictionary.idx2word[predicted_word_idx]
            print(w);
            if w == '<eos>':
                break


def train(device, corpus, epoch):
    # Turn on training mode which enables dropout.
    model.train()
    total_loss = 0.
    start_time = time.time()
    ntokens = len(corpus.dictionary)
    
    batchIdx = 0;
    for batch, target in train_data:
        batch = batch.to(device)
        answer = target.to(device)

        answer_input = answer[:-1].unsqueeze(0)  # Remove last token for input
        target = answer[1:].unsqueeze(0)  # Shift left for target
        
        optimizer.zero_grad()
        output, _ = model(batch, answer_input)
        output = output.view(-1, ntokens)
        target = target.view(-1)

        loss = criterion(output, target)
        loss.backward()
        optimizer.step()

        total_loss += loss.item()
        batchIdx+=1

        if batchIdx % args.log_interval == 0 and batchIdx > 0:
            cur_loss = total_loss / args.log_interval
            elapsed = time.time() - start_time
            print('| epoch {:3d} | {:5d}/{:5d} batches | ms/batch {:5.2f} | '
                    'loss {:5.2f} | ppl {:8.2f}'.format(
                epoch, batchIdx, len(train_data.dataset) // args.batch_size, 
                elapsed * 1000 / args.log_interval, cur_loss, math.exp(cur_loss)))
            total_loss = 0
            start_time = time.time()
        if args.dry_run:
            break

    return total_loss

encoder = lstm_model.Encoder(ntokens, args.emsize, args.nhid, args.nlayers)
decoder = lstm_model.Decoder(ntokens, args.emsize, args.nhid, args.nlayers)
model = lstm_model.Seq2Seq(encoder, decoder).to(device)

loss_weights = torch.ones(len(corpus.dictionary.word2idx)).to(device)
loss_weights[corpus.dictionary.word2idx['<eos>']] = 5.0

criterion = nn.CrossEntropyLoss(ignore_index=0, weight=loss_weights)  # Ignore padding token
optimizer = optim.Adam(model.parameters(), lr=0.0005)

